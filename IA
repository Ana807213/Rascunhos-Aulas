12/02

O n8n √© uma ferramenta de automa√ß√£o.
Explicando bem simples üëá
Ele serve para ligar sistemas e automatizar tarefas, sem voc√™ precisar fazer tudo manualmente.
üìå Exemplo pr√°tico:
Chegou um e-mail ‚ûú salvar anexo no Google Drive
Novo cliente no site ‚ûú cadastrar no banco de dados
Venda realizada ‚ûú enviar mensagem no WhatsApp
Formul√°rio preenchido ‚ûú criar tarefa no Trello
Tudo isso acontece sozinho, depois que voc√™ configura.

üß† Em resumo:
O n8n √© tipo um ‚Äúconector inteligente‚Äù entre sistemas.
Voc√™ cria fluxos (arrastando blocos) e ele executa as a√ß√µes automaticamente.
Como voc√™ √© Tech Lead, voc√™ pode usar o n8n para:
Integrar APIs
Automatizar rotinas internas
Criar micro fluxos sem precisar subir um backend inteiro
Orquestrar webhooks


20/02
Windows power shell
Comando : wsl --install
Resultado: Ubuntu instalado
Reiniciar a maquina 
Vai abrir uma tela informando que esta Baixando o Ubuntu
usuario: ite
senha: 123
Comando: sudo apt update
Senha: 123
Comando: sudo apt upgrade
Comando: Y
Comando: sudo apt install python3-full
Comando: Y
Comando: sudo apt install python3-venv
Comando que pegamos na internet: curl -LsSf https://astral.sh/uv/install.sh | sh
Comando: cd
Comando: mkdir ia
Comando: cd ia 
Comando: mkdir design-algoritmos
Comando: cd design-algoritmos
Comando: python3 -m venv .venv
Comando: source .venv/bin/activate
Comando: code .
VS CODE: criar um arquivo chamado recursive.py
VS CODE: Instala a extensao de python
VS CODE: colocar esse codigo no arquivo recursive.py
"""
Exemplo de recursividade com fatorial de n.

Fatorial de 4:
4= 4*3*2*1*1 = 24
"""

def fatorial(n):
    if n == 0:
        return 1
    return n * fatorial(n-1)

print(fatorial(100))
Comando: python3 recursive.py
Resultado ser√°: 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000

Aula 26/02
VS CODE: Arquivo busca.py
def busca(lista: list, chave: int):
    for indice, valor in enumerate(lista):
        if valor == chave:
            return indice
    return -1


lista = [3, 4, 1, 6, 14]
print(busca(lista, 6))

Comando: python3 busca.py
Resultado: 3

VS CODE: Arquivo binary_search.py
def binary_search(array, key, start, end):
    """
    Busca bin√°ria em um array ordenado
    Retorna o √≠ndice do elemento ou -1 se n√£o encontrar
    """

    while start <= end:
        # calcular o √≠ndice do meio
        mid = start + (end - start) // 2

        # verificar se o elemento do meio √© o procurado
        if array[mid] == key:
            return mid

        elif array[mid] < key:
            # elimina a metade esquerda
            start = mid + 1
        else:
            # elimina a metade direita
            end = mid - 1

    return -1  # elemento n√£o encontrado

array = [4,6,9,13,14,18,21,24,38]
key = 38
result = binary_search (array,key,len(array)-1,0)
print (result)

Comando: python3 binary_search.py
Resultado: -1

VS CODE: Arquivo merge_sort.py
def sort(unsorted: list):
    
    """
    Sort usa paradiga 'Dividir para conquistar'

    Etapas:
    1. Dividir a lista ao meio
    2. Resolver recursivamente cada metade
    3. Combinar (merge) as metades ordenadas

    A recursao continua at√© que cada metade tenha apenas 1 elemento.
    Uma lista com 1 elemento ja esta ordenada    
    """
    if len(unsorted) <= 1:
        return unsorted

    #Etapa 1 - dividir 
    mid = len(unsorted) // 2
    left_unsorted = unsorted[:mid]
    right_unsorted = unsorted[mid:]

    #Etapa 2 - Conquista (resolver recursivamente)
    left_sorted = sort(left_unsorted)
    right_sorted = sort(right_unsorted)

    #Etapa 2 - Combinar as metadas ja ordenadas 
    return merge(left_sorted, right_sorted)


def merge(left: list, right: list):
    """
    Recebe duas listas e devolve uma unica lista ordenada
    """

    i = 0
    j = 0
    merged = []

    # Enquanto ainda houver elementos nas 2 listas 
    while i < len(left) and j < len(right):
        # Comparar os elementos atuais 
        if left[i] < right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1    #avan√ßa na lista

    #se sobrar elementos na esquerda
    while i < len(left):
        merged.append(left[i])
        i += 1

    # se sobrar elementos na direita
    while j < len(right):
        merged.append(right[j])
        j += 1

    return merged


unsorted = [10, 1, 20, 3, 5, 2, 18, 0]
print(sort(unsorted))

Comando: python3 merge_sort.py
Resultado: [0,1,2,3,5,10,18,20]

27/02
Euclidiana 
Percurso
Linear (euclidiana)

Comando: mkdir buscas
Comando: cd buscas
Comando: python3 -m venv .venv
Comando: code .

VS CODE: Arquivo gredy.py
# Grafo representado como dicion√°rio
# Cada cidade aponta para vizinhos e seus custos
reais

import heapq

romania_map = {
"Arad": {"Zerind": 75, "Timisoara": 118,
"Sibiu": 140},
"Zerind": {"Arad": 75, "Oradea": 71},
"Oradea": {"Zerind": 71, "Sibiu": 151},
"Timisoara": {"Arad": 118, "Lugoj": 111},
"Lugoj": {"Timisoara": 111, "Mehadia": 70},
"Mehadia": {"Lugoj": 70, "Drobeta": 75},
"Drobeta": {"Mehadia": 75, "Craiova": 120},
"Craiova": {"Drobeta": 120, "Rimnicu Vilcea":146, "Pitesti": 138},
"Sibiu": {"Arad": 140, "Oradea": 151,
"Fagaras": 99, "Rimnicu Vilcea": 80},
"Pitesti": {"Rimciu Vilcea":97, "Craiova":138,"Bucharest": 101},
"Bucharest": {"Fagaras":211, "Pitesti":101}

}

heuristic = {"Arad": 366,
"Zerind": 374,
"Oradea": 380,
"Timisoara": 329,
"Lugoj": 244,
"Mehadia": 241,
"Drobeta": 242,
"Craiova": 160,
"Sibiu": 253,
"Rimnicu Vilcea":193,
"Fagaras": 176,
"Pitesti":100,
"Bucharest": 0
}

def greedy_best_first_search(graph, heuristic, start, goal):
    """
     grap - o mapa
    heuristic - a heuristica
    start -de onde esta partindo
    goal - onde quer chegar
    """
    #separar o que foi explorado do nao explorado
    frontier = []
    #inserindo n√≥ inicial (Arad)
    #h(n) = h(n)
    heapq.heappush (frontier(heuristic[start],start))

    """
    Sibiu <--- Arad
    """
    came_from = {}

    """
    Conjunto de n√≥s ja visitados(expandidos)
    Evita ciclo infinito;
    Se torna uma busca rapida - Big O (1)
    """
        visited = set()

    """
    Enquanto houver n√≥s para explorar, fa√ßa recursivamente.
    Se a fronteira esvaziar -> nao existe solu√ß√£o.
    """
    
    while frontier:
        """
        Remove o n√≥ com menor heuristica
        '_' ignora o valor da heuristica
        'current' = recebe a cidade
        """
        _, current = heap.heappop(frontier)
        print (f"N√≥ Expandido: {current}")

        if current == goal:
            return reconstruct_path (came_from, start, goal)

def reconstruct_path()
    ...
path = greedy_best_first_search(
    romania_map,
    heuristic,
    start ="Arad",
    goal = "Bucharest"
)

print (path)
